import { Injectable, OnModuleDestroy } from '@nestjs/common';
import {
  chromium,
  Browser,
  BrowserContext,
  Page,
  BrowserContextOptions,
} from 'playwright';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

export interface PlaywrightContext {
  browser: Browser;
  context: BrowserContext;
  page: Page;
  videoDir?: string;
}

export interface PlaywrightOptions {
  headless?: boolean;
  recordVideo?: boolean;
}

/**
 * QA ID Tagger Script - Same algorithm as the Chrome extension
 * This gets injected into pages during test execution to add data-qa-id attributes
 */
const QA_TAGGER_SCRIPT = `
(function() {
  // Prevent multiple injections
  if (window.__TESTBLOC_QA_TAGGER_INJECTED) return;
  window.__TESTBLOC_QA_TAGGER_INJECTED = true;

  // Check if a string looks auto-generated (hashed class names, etc.)
  function looksAutoGenerated(str) {
    const patterns = [
      /^[a-z]{1,3}[0-9a-f]{4,}$/i,           // css-1a2b3c4
      /^[a-z]+-[0-9a-f]{6,}$/i,               // styles-a1b2c3d4
      /^_[a-z0-9]+$/i,                         // _1234abc
      /^[a-z]{2,4}__[a-z]+_[a-z0-9]+$/i,     // sc__button_xyz123
      /[a-f0-9]{8,}/i,                         // long hex strings
      /^:r[0-9]+:$/,                           // React useId
      /^css-/i,                                // Emotion CSS
      /^sc-/i,                                 // styled-components
      /^MuiBox-root/i,                         // Material UI
      /^chakra-/i,                             // Chakra UI
    ];
    return patterns.some(p => p.test(str));
  }

  function inferRole(element) {
    const ariaRole = element.getAttribute('role');
    if (ariaRole) return ariaRole;

    const tagName = element.tagName.toLowerCase();
    const roleMap = {
      button: 'button',
      a: 'link',
      input: 'textbox',
      textarea: 'textbox',
      select: 'combobox',
      img: 'img',
      h1: 'heading', h2: 'heading', h3: 'heading',
      h4: 'heading', h5: 'heading', h6: 'heading',
      nav: 'navigation',
      main: 'main',
      header: 'banner',
      footer: 'contentinfo',
      form: 'form',
      table: 'table',
      ul: 'list', ol: 'list',
      li: 'listitem',
    };

    if (roleMap[tagName]) return roleMap[tagName];

    if (tagName === 'input') {
      const type = element.type?.toLowerCase();
      const inputRoles = {
        button: 'button',
        submit: 'button',
        reset: 'button',
        checkbox: 'checkbox',
        radio: 'radio',
        search: 'searchbox',
        number: 'spinbutton',
        range: 'slider',
      };
      return inputRoles[type] || 'textbox';
    }

    return undefined;
  }

  function getAccessibleName(element) {
    const ariaLabel = element.getAttribute('aria-label');
    if (ariaLabel) return ariaLabel.trim();

    const labelledBy = element.getAttribute('aria-labelledby');
    if (labelledBy) {
      const labelEl = document.getElementById(labelledBy);
      if (labelEl) return labelEl.textContent?.trim();
    }

    if (element.placeholder) return element.placeholder.trim();
    if (element.alt) return element.alt.trim();

    const tagName = element.tagName.toLowerCase();
    if (['button', 'a'].includes(tagName)) {
      const text = element.textContent?.trim();
      if (text && text.length <= 80) return text;
    }

    if (tagName === 'input' && ['button', 'submit', 'reset'].includes(element.type)) {
      return element.value?.trim();
    }

    if (element.id) {
      const label = document.querySelector('label[for="' + element.id + '"]');
      if (label) return label.textContent?.trim();
    }

    const parentLabel = element.closest('label');
    if (parentLabel) {
      const clone = parentLabel.cloneNode(true);
      clone.querySelectorAll('input, select, textarea').forEach(el => el.remove());
      const text = clone.textContent?.trim();
      if (text) return text;
    }

    // For images without alt, try to extract filename from src
    if (tagName === 'img' && element.src) {
      try {
        const url = new URL(element.src);
        const filename = url.pathname.split('/').pop();
        if (filename) {
          // Remove extension and clean up
          const name = filename.replace(/\.[^.]+$/, '').replace(/[-_]/g, '');
          if (name && name.length > 2) return name;
        }
      } catch (e) {}
    }

    // For links without text, try href path
    if (tagName === 'a' && element.href) {
      try {
        const url = new URL(element.href);
        const path = url.pathname.split('/').filter(Boolean).pop();
        if (path && path.length > 2 && path.length <= 30) return path;
      } catch (e) {}
    }

    // Try element's id as last resort
    if (element.id && element.id.length <= 30 && !looksAutoGenerated(element.id)) {
      return element.id;
    }

    // Try meaningful class name
    const classes = Array.from(element.classList || []);
    const meaningfulClass = classes.find(c =>
      c.length > 2 && c.length <= 20 &&
      !looksAutoGenerated(c) &&
      !/^(active|hidden|show|hide|open|closed|disabled|enabled)$/i.test(c)
    );
    if (meaningfulClass) return meaningfulClass;

    return undefined;
  }

  function ensureQaId(element) {
    // Check for existing test IDs
    const existing = element.getAttribute('data-testid') ||
                    element.getAttribute('data-qa') ||
                    element.getAttribute('data-qa-id');
    if (existing) return existing;

    const role = inferRole(element) || 'element';
    const name = getAccessibleName(element);
    const hint = name ?
      name.substring(0, 20).replace(/[^a-zA-Z0-9]/g, '').toLowerCase() :
      element.tagName.toLowerCase();

    let qaId = 'qa:' + role + ':' + hint;

    // Ensure uniqueness
    let counter = 0;
    let finalId = qaId;
    while (document.querySelector('[data-qa-id="' + finalId + '"]')) {
      counter++;
      finalId = qaId + ':' + counter;
    }

    element.setAttribute('data-qa-id', finalId);
    return finalId;
  }

  function tagAllElements() {
    // Tag interactive elements
    const selectors = [
      'button', 'a', 'input', 'textarea', 'select',
      '[role="button"]', '[role="link"]', '[role="checkbox"]',
      '[role="radio"]', '[role="tab"]', '[role="menuitem"]',
      '[onclick]', '[ng-click]', '[data-action]'
    ];

    const elements = document.querySelectorAll(selectors.join(','));
    elements.forEach(el => {
      try {
        ensureQaId(el);
      } catch (e) {
        // Ignore errors for individual elements
      }
    });
  }

  // Tag elements on initial load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', tagAllElements);
  } else {
    tagAllElements();
  }

  // Re-tag on DOM mutations (for SPAs)
  const observer = new MutationObserver((mutations) => {
    let hasNewNodes = false;
    for (const mutation of mutations) {
      if (mutation.addedNodes.length > 0) {
        hasNewNodes = true;
        break;
      }
    }
    if (hasNewNodes) {
      // Debounce
      clearTimeout(window.__testblocTagTimeout);
      window.__testblocTagTimeout = setTimeout(tagAllElements, 100);
    }
  });

  observer.observe(document.body || document.documentElement, {
    childList: true,
    subtree: true
  });
})();
`;

@Injectable()
export class PlaywrightService implements OnModuleDestroy {
  private activeBrowsers: Set<Browser> = new Set();

  async onModuleDestroy() {
    // Cleanup all browsers on module shutdown
    for (const browser of this.activeBrowsers) {
      try {
        await browser.close();
      } catch {
        // Ignore errors during cleanup
      }
    }
    this.activeBrowsers.clear();
  }

  /**
   * Create a new browser context for test execution
   */
  async createContext(
    playwrightOptions?: PlaywrightOptions,
    contextOptions?: BrowserContextOptions,
  ): Promise<PlaywrightContext> {
    const headless = playwrightOptions?.headless ?? true; // Default to headless
    const recordVideo = playwrightOptions?.recordVideo ?? true; // Default to recording video

    const browser = await chromium.launch({
      headless,
      slowMo: headless ? 0 : 500, // Only slow down in headed mode for visibility
    });

    this.activeBrowsers.add(browser);

    // Create temp directory for video recording
    let videoDir: string | undefined;
    if (recordVideo) {
      videoDir = fs.mkdtempSync(path.join(os.tmpdir(), 'testbloc-video-'));
    }

    const context = await browser.newContext({
      viewport: { width: 1280, height: 720 },
      ...(recordVideo && videoDir
        ? {
            recordVideo: {
              dir: videoDir,
              size: { width: 1280, height: 720 },
            },
          }
        : {}),
      ...contextOptions,
    });

    // Inject QA tagger script on every page load
    await context.addInitScript(QA_TAGGER_SCRIPT);

    const page = await context.newPage();

    // Set default timeouts
    page.setDefaultTimeout(30000); // 30 seconds
    page.setDefaultNavigationTimeout(30000);

    return { browser, context, page, videoDir };
  }

  /**
   * Capture a full page screenshot as base64
   */
  async captureScreenshot(page: Page): Promise<string> {
    const buffer = await page.screenshot({
      type: 'png',
      fullPage: false, // Capture viewport only for performance
    });
    return buffer.toString('base64');
  }

  /**
   * Capture an element screenshot as base64
   */
  async captureElementScreenshot(
    page: Page,
    selector: string,
  ): Promise<string | null> {
    try {
      const element = page.locator(selector).first();
      const buffer = await element.screenshot({ type: 'png' });
      return buffer.toString('base64');
    } catch {
      // Return null if element not found
      return null;
    }
  }

  /**
   * Get video as base64 data URL after test execution
   * Must be called after closing the page but before closing the browser
   */
  async getVideoAsBase64(page: Page, videoDir?: string): Promise<string | null> {
    if (!videoDir) return null;

    try {
      // Get the video path from the page (Playwright saves it automatically)
      const video = page.video();
      if (!video) return null;

      // Wait for video to be saved
      const videoPath = await video.path();
      if (!videoPath || !fs.existsSync(videoPath)) return null;

      // Read and convert to base64
      const videoBuffer = fs.readFileSync(videoPath);
      const base64 = videoBuffer.toString('base64');

      return `data:video/webm;base64,${base64}`;
    } catch (error) {
      console.error('Failed to get video:', error);
      return null;
    }
  }

  /**
   * Cleanup video directory
   */
  cleanupVideoDir(videoDir?: string): void {
    if (!videoDir) return;

    try {
      // Remove all files in the directory
      const files = fs.readdirSync(videoDir);
      for (const file of files) {
        fs.unlinkSync(path.join(videoDir, file));
      }
      // Remove the directory
      fs.rmdirSync(videoDir);
    } catch {
      // Ignore cleanup errors
    }
  }

  /**
   * Close browser and cleanup resources
   */
  async close(browser: Browser, videoDir?: string): Promise<void> {
    this.activeBrowsers.delete(browser);
    try {
      await browser.close();
    } catch {
      // Ignore errors during cleanup
    }

    // Cleanup video directory
    this.cleanupVideoDir(videoDir);
  }
}
