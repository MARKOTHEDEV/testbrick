/**
 * TestBloc Recorder - Content Script
 *
 * Injected into web pages to:
 * - Display floating recording badge
 * - Capture user interactions (clicks, inputs, navigation)
 * - Generate robust locators using LocatorBundle approach
 * - Support assertion mode for element selection
 */

(function () {
  'use strict';

  // Prevent multiple injections
  if (window.__TESTBLOC_RECORDER_INJECTED) {
    return;
  }
  window.__TESTBLOC_RECORDER_INJECTED = true;

  // ============================================
  // RECORDING STATE
  // ============================================

  let isRecording = false;
  let isAssertionMode = false;
  let recordingContext = {
    testId: null,
    testName: null,
    baseUrl: null,
  };

  // ============================================
  // LOCATOR BUNDLE - Selector Generation
  // ============================================

  /**
   * LocatorBundle captures multiple selector strategies for an element
   * Priority order (most stable first):
   * 1. Role + accessible name (getByRole)
   * 2. Test ID (data-testid, data-qa, etc.)
   * 3. Label (form field labels)
   * 4. Placeholder
   * 5. Text content
   * 6. Alt text
   * 7. Title attribute
   * 8. CSS selector
   * 9. XPath (last resort)
   */

  /**
   * Check if a string looks auto-generated (hashed class names, etc.)
   */
  function looksAutoGenerated(str) {
    const patterns = [
      /^[a-z]{1,3}[0-9a-f]{4,}$/i,           // css-1a2b3c4
      /^[a-z]+-[0-9a-f]{6,}$/i,               // styles-a1b2c3d4
      /^_[a-z0-9]+$/i,                         // _1234abc
      /^[a-z]{2,4}__[a-z]+_[a-z0-9]+$/i,     // sc__button_xyz123
      /[a-f0-9]{8,}/i,                         // long hex strings
      /^:r[0-9]+:$/,                           // React useId
      /^css-/i,                                // Emotion CSS
      /^sc-/i,                                 // styled-components
      /^MuiBox-root/i,                         // Material UI
      /^chakra-/i,                             // Chakra UI
    ];
    return patterns.some(p => p.test(str));
  }

  /**
   * Infer ARIA role from element
   */
  function inferRole(element) {
    const ariaRole = element.getAttribute('role');
    if (ariaRole) return ariaRole;

    const tagName = element.tagName.toLowerCase();
    const roleMap = {
      button: 'button',
      a: 'link',
      input: 'textbox',
      textarea: 'textbox',
      select: 'combobox',
      img: 'img',
      h1: 'heading', h2: 'heading', h3: 'heading',
      h4: 'heading', h5: 'heading', h6: 'heading',
      nav: 'navigation',
      main: 'main',
      header: 'banner',
      footer: 'contentinfo',
      form: 'form',
      table: 'table',
      ul: 'list', ol: 'list',
      li: 'listitem',
    };

    if (roleMap[tagName]) return roleMap[tagName];

    // Input type specific roles
    if (tagName === 'input') {
      const type = element.type?.toLowerCase();
      const inputRoles = {
        button: 'button',
        submit: 'button',
        reset: 'button',
        checkbox: 'checkbox',
        radio: 'radio',
        search: 'searchbox',
        number: 'spinbutton',
        range: 'slider',
      };
      return inputRoles[type] || 'textbox';
    }

    return undefined;
  }

  /**
   * Get accessible name for an element
   */
  function getAccessibleName(element) {
    // aria-label
    const ariaLabel = element.getAttribute('aria-label');
    if (ariaLabel) return ariaLabel.trim();

    // aria-labelledby
    const labelledBy = element.getAttribute('aria-labelledby');
    if (labelledBy) {
      const labelEl = document.getElementById(labelledBy);
      if (labelEl) return labelEl.textContent?.trim();
    }

    // Placeholder
    if (element.placeholder) return element.placeholder.trim();

    // Alt text for images
    if (element.alt) return element.alt.trim();

    // Text content for buttons/links
    const tagName = element.tagName.toLowerCase();
    if (['button', 'a'].includes(tagName)) {
      const text = element.textContent?.trim();
      if (text && text.length <= 80) return text;
    }

    // Value for input buttons
    if (tagName === 'input' && ['button', 'submit', 'reset'].includes(element.type)) {
      return element.value?.trim();
    }

    // Associated label
    if (element.id) {
      const label = document.querySelector(`label[for="${element.id}"]`);
      if (label) return label.textContent?.trim();
    }

    // Wrapping label
    const parentLabel = element.closest('label');
    if (parentLabel) {
      const clone = parentLabel.cloneNode(true);
      clone.querySelectorAll('input, select, textarea').forEach(el => el.remove());
      const text = clone.textContent?.trim();
      if (text) return text;
    }

    // For images without alt, try to extract filename from src
    if (tagName === 'img' && element.src) {
      try {
        const url = new URL(element.src);
        const filename = url.pathname.split('/').pop();
        if (filename) {
          // Remove extension and clean up
          const name = filename.replace(/\.[^.]+$/, '').replace(/[-_]/g, '');
          if (name && name.length > 2) return name;
        }
      } catch (e) {}
    }

    // For links without text, try href path
    if (tagName === 'a' && element.href) {
      try {
        const url = new URL(element.href);
        const path = url.pathname.split('/').filter(Boolean).pop();
        if (path && path.length > 2 && path.length <= 30) return path;
      } catch (e) {}
    }

    // Try element's id as last resort
    if (element.id && element.id.length <= 30 && !looksAutoGenerated(element.id)) {
      return element.id;
    }

    // Try meaningful class name
    const classes = Array.from(element.classList || []);
    const meaningfulClass = classes.find(c =>
      c.length > 2 && c.length <= 20 &&
      !looksAutoGenerated(c) &&
      !/^(active|hidden|show|hide|open|closed|disabled|enabled)$/i.test(c)
    );
    if (meaningfulClass) return meaningfulClass;

    return undefined;
  }

  /**
   * Get associated label for form fields
   */
  function getAssociatedLabel(element) {
    if (element.id) {
      const label = document.querySelector(`label[for="${element.id}"]`);
      if (label) return label.textContent?.trim();
    }

    const parentLabel = element.closest('label');
    if (parentLabel) {
      const clone = parentLabel.cloneNode(true);
      clone.querySelectorAll('input, select, textarea').forEach(el => el.remove());
      const text = clone.textContent?.trim();
      if (text) return text;
    }

    const labelledBy = element.getAttribute('aria-labelledby');
    if (labelledBy) {
      const labelEl = document.getElementById(labelledBy);
      if (labelEl) return labelEl.textContent?.trim();
    }

    return undefined;
  }

  /**
   * Get visible text content
   */
  function getVisibleText(element) {
    const tagName = element.tagName.toLowerCase();

    if (['button', 'a'].includes(tagName)) {
      const clone = element.cloneNode(true);
      clone.querySelectorAll('button, a, input, select, textarea').forEach(el => el.remove());
      const text = clone.textContent?.trim();
      if (text && text.length > 0 && text.length <= 100) return text;
    }

    if (tagName === 'input' && ['button', 'submit', 'reset'].includes(element.type)) {
      return element.value?.trim();
    }

    return undefined;
  }

  /**
   * Generate CSS selector for element
   */
  function generateCssSelector(element) {
    const parts = [];
    let current = element;
    let depth = 0;
    const maxDepth = 5;

    while (current && current !== document.body && depth < maxDepth) {
      let selector = current.tagName.toLowerCase();

      // Prefer ID if stable
      if (current.id && !looksAutoGenerated(current.id)) {
        parts.unshift(`#${CSS.escape(current.id)}`);
        break;
      }

      // Add stable classes
      const stableClasses = Array.from(current.classList || [])
        .filter(cls => !looksAutoGenerated(cls))
        .slice(0, 2);

      if (stableClasses.length > 0) {
        selector += stableClasses.map(cls => `.${CSS.escape(cls)}`).join('');
      }

      // Add nth-of-type for uniqueness
      const parent = current.parentElement;
      if (parent) {
        const siblings = Array.from(parent.children)
          .filter(s => s.tagName === current.tagName);
        if (siblings.length > 1) {
          const index = siblings.indexOf(current) + 1;
          selector += `:nth-of-type(${index})`;
        }
      }

      parts.unshift(selector);
      current = current.parentElement;
      depth++;
    }

    return parts.join(' > ');
  }

  /**
   * Generate XPath for element
   */
  function generateXPath(element) {
    const parts = [];
    let current = element;

    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();

      if (current.id && !looksAutoGenerated(current.id)) {
        parts.unshift(`//*[@id="${current.id}"]`);
        break;
      }

      const parent = current.parentElement;
      if (parent) {
        const siblings = Array.from(parent.children)
          .filter(s => s.tagName === current.tagName);
        if (siblings.length > 1) {
          const index = siblings.indexOf(current) + 1;
          selector += `[${index}]`;
        }
      }

      parts.unshift(selector);
      current = current.parentElement;
    }

    return '//' + parts.join('/');
  }

  /**
   * Capture full LocatorBundle for an element
   */
  function captureLocators(element) {
    const locators = {};

    // 1. Role locator
    const role = inferRole(element);
    if (role) {
      const name = getAccessibleName(element);
      locators.role = { role, name: name || undefined };
    }

    // 2. Test ID
    const testId = element.getAttribute('data-testid') ||
                   element.getAttribute('data-test') ||
                   element.getAttribute('data-qa') ||
                   element.getAttribute('data-cy');
    if (testId) {
      locators.testId = testId;
    }

    // 3. Label
    const label = getAssociatedLabel(element);
    if (label) {
      locators.label = label;
    }

    // 4. Placeholder
    if (element.placeholder) {
      locators.placeholder = element.placeholder.trim();
    }

    // 5. Text
    const text = getVisibleText(element);
    if (text) {
      locators.text = text;
    }

    // 6. Alt text
    if (element.alt) {
      locators.altText = element.alt.trim();
    }

    // 7. Title
    const title = element.getAttribute('title');
    if (title) {
      locators.title = title.trim();
    }

    // 8. CSS selector
    locators.css = generateCssSelector(element);

    // 9. XPath
    locators.xpath = generateXPath(element);

    return locators;
  }

  /**
   * Generate/ensure data-qa-id on element
   */
  function ensureQaId(element) {
    const existing = element.getAttribute('data-testid') ||
                    element.getAttribute('data-qa') ||
                    element.getAttribute('data-qa-id');
    if (existing) return existing;

    const role = inferRole(element) || 'element';
    const name = getAccessibleName(element);
    const hint = name ?
      name.substring(0, 20).replace(/[^a-zA-Z0-9]/g, '').toLowerCase() :
      element.tagName.toLowerCase();

    let qaId = `qa:${role}:${hint}`;

    // Ensure uniqueness
    let counter = 0;
    let finalId = qaId;
    while (document.querySelector(`[data-qa-id="${finalId}"]`)) {
      counter++;
      finalId = `${qaId}:${counter}`;
    }

    element.setAttribute('data-qa-id', finalId);
    return finalId;
  }

  // ============================================
  // FLOATING BADGE UI
  // ============================================

  let badgeElement = null;
  let badgeShadow = null; // Store reference to shadow root
  let assertionOverlay = null;

  function createBadgeUI() {
    if (badgeElement) return;

    // Create shadow DOM container for isolation
    const container = document.createElement('div');
    container.id = 'testbloc-recorder-root';
    container.style.cssText = 'all: initial; position: fixed; z-index: 2147483647;';

    const shadow = container.attachShadow({ mode: 'closed' });
    badgeShadow = shadow; // Store reference since closed mode won't expose shadowRoot

    shadow.innerHTML = `
      <style>
        * {
          margin: 0;
          padding: 0;
          box-sizing: border-box;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .badge {
          position: fixed;
          top: 16px;
          right: 16px;
          background: #1f2937;
          border-radius: 12px;
          padding: 12px 16px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.3);
          cursor: move;
          user-select: none;
          min-width: 200px;
          z-index: 2147483647;
        }

        .badge-header {
          display: flex;
          align-items: center;
          gap: 8px;
          margin-bottom: 8px;
        }

        .recording-dot {
          width: 10px;
          height: 10px;
          background: #ef4444;
          border-radius: 50%;
          animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
          0%, 100% { opacity: 1; }
          50% { opacity: 0.4; }
        }

        .badge-title {
          color: white;
          font-size: 13px;
          font-weight: 500;
        }

        .badge-subtitle {
          color: #9ca3af;
          font-size: 11px;
          margin-bottom: 12px;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }

        .badge-buttons {
          display: flex;
          gap: 8px;
        }

        .badge-btn {
          flex: 1;
          padding: 8px 12px;
          border: none;
          border-radius: 6px;
          font-size: 12px;
          font-weight: 500;
          cursor: pointer;
          display: flex;
          align-items: center;
          justify-content: center;
          gap: 4px;
          transition: all 0.15s;
        }

        .badge-btn-assert {
          background: #3b82f6;
          color: white;
        }

        .badge-btn-assert:hover {
          background: #2563eb;
        }

        .badge-btn-assert.active {
          background: #f59e0b;
        }

        .badge-btn-stop {
          background: #ef4444;
          color: white;
        }

        .badge-btn-stop:hover {
          background: #dc2626;
        }

        .assertion-mode-indicator {
          background: #f59e0b;
          color: #1f2937;
          font-size: 11px;
          padding: 4px 8px;
          border-radius: 4px;
          margin-bottom: 8px;
          text-align: center;
        }
      </style>

      <div class="badge" id="badge">
        <div class="badge-header">
          <div class="recording-dot"></div>
          <span class="badge-title">Recording</span>
        </div>
        <div class="badge-subtitle" id="badge-subtitle">to "${recordingContext.testName || 'Test'}"</div>
        <div class="assertion-mode-indicator" id="assertion-indicator" style="display: none;">
          Click an element to add assertion
        </div>
        <div class="badge-buttons">
          <button class="badge-btn badge-btn-assert" id="btn-assert">+ Assert</button>
          <button class="badge-btn badge-btn-stop" id="btn-stop">Stop</button>
        </div>
      </div>
    `;

    document.body.appendChild(container);
    badgeElement = shadow.querySelector('#badge');

    // Make badge draggable
    makeDraggable(badgeElement);

    // Button handlers
    shadow.querySelector('#btn-assert').addEventListener('click', toggleAssertionMode);
    shadow.querySelector('#btn-stop').addEventListener('click', () => stopRecording('badge'));

    return shadow;
  }

  function makeDraggable(element) {
    let isDragging = false;
    let startX, startY, startLeft, startTop;

    element.addEventListener('mousedown', (e) => {
      if (e.target.tagName === 'BUTTON') return;

      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;

      const rect = element.getBoundingClientRect();
      startLeft = rect.left;
      startTop = rect.top;

      element.style.transition = 'none';
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      element.style.left = `${startLeft + deltaX}px`;
      element.style.top = `${startTop + deltaY}px`;
      element.style.right = 'auto';
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
      element.style.transition = '';
    });
  }

  function removeBadgeUI() {
    const container = document.getElementById('testbloc-recorder-root');
    if (container) {
      container.remove();
    }
    badgeElement = null;
    badgeShadow = null;
  }

  // ============================================
  // ASSERTION MODE
  // ============================================

  let highlightedElement = null;
  let assertionPopup = null;

  function toggleAssertionMode() {
    isAssertionMode = !isAssertionMode;
    console.log('[TestBloc] toggleAssertionMode called, isAssertionMode:', isAssertionMode);

    if (!badgeShadow) {
      console.log('[TestBloc] toggleAssertionMode: badgeShadow is null!');
      return;
    }

    const indicator = badgeShadow.querySelector('#assertion-indicator');
    const assertBtn = badgeShadow.querySelector('#btn-assert');

    if (isAssertionMode) {
      indicator.style.display = 'block';
      assertBtn.classList.add('active');
      assertBtn.textContent = 'Cancel';
      document.body.style.cursor = 'crosshair';
      createAssertionOverlay();
    } else {
      indicator.style.display = 'none';
      assertBtn.classList.remove('active');
      assertBtn.textContent = '+ Assert';
      document.body.style.cursor = '';
      removeAssertionOverlay();
      removeAssertionPopup();
    }
  }

  function createAssertionOverlay() {
    if (assertionOverlay) return;

    assertionOverlay = document.createElement('div');
    assertionOverlay.id = 'testbloc-assertion-overlay';
    assertionOverlay.style.cssText = `
      position: fixed;
      pointer-events: none;
      border: 2px solid #3b82f6;
      background: rgba(59, 130, 246, 0.1);
      border-radius: 4px;
      z-index: 2147483646;
      display: none;
      transition: all 0.1s ease;
    `;
    document.body.appendChild(assertionOverlay);
  }

  function removeAssertionOverlay() {
    if (assertionOverlay) {
      assertionOverlay.remove();
      assertionOverlay = null;
    }
    highlightedElement = null;
  }

  function highlightElement(element) {
    if (!assertionOverlay || !element) return;

    const rect = element.getBoundingClientRect();
    assertionOverlay.style.display = 'block';
    assertionOverlay.style.left = `${rect.left - 2}px`;
    assertionOverlay.style.top = `${rect.top - 2}px`;
    assertionOverlay.style.width = `${rect.width + 4}px`;
    assertionOverlay.style.height = `${rect.height + 4}px`;
    highlightedElement = element;
  }

  function showAssertionPopup(element, x, y) {
    removeAssertionPopup();

    const popup = document.createElement('div');
    popup.id = 'testbloc-assertion-popup';
    popup.style.cssText = `
      position: fixed;
      left: ${x}px;
      top: ${y}px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      z-index: 2147483647;
      padding: 8px 0;
      min-width: 180px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    `;

    const elementText = element.textContent?.trim().substring(0, 30) || '';

    const options = [
      { type: 'text_equals', label: 'Assert text equals', value: elementText },
      { type: 'text_contains', label: 'Assert text contains', value: elementText },
      { type: 'is_visible', label: 'Assert is visible', value: null },
      { type: 'exists', label: 'Assert exists', value: null },
    ];

    options.forEach(opt => {
      const btn = document.createElement('button');
      btn.style.cssText = `
        display: block;
        width: 100%;
        padding: 10px 16px;
        border: none;
        background: none;
        text-align: left;
        cursor: pointer;
        font-size: 13px;
        color: #1f2937;
      `;
      btn.textContent = opt.label;
      btn.addEventListener('mouseenter', () => btn.style.background = '#f3f4f6');
      btn.addEventListener('mouseleave', () => btn.style.background = 'none');
      btn.addEventListener('click', () => {
        captureAssertion(element, opt.type, opt.value);
        removeAssertionPopup();
        toggleAssertionMode();
      });
      popup.appendChild(btn);
    });

    document.body.appendChild(popup);
    assertionPopup = popup;

    // Adjust position if off-screen
    const popupRect = popup.getBoundingClientRect();
    if (popupRect.right > window.innerWidth) {
      popup.style.left = `${window.innerWidth - popupRect.width - 10}px`;
    }
    if (popupRect.bottom > window.innerHeight) {
      popup.style.top = `${window.innerHeight - popupRect.height - 10}px`;
    }
  }

  function removeAssertionPopup() {
    if (assertionPopup) {
      assertionPopup.remove();
      assertionPopup = null;
    }
  }

  function captureAssertion(element, assertionType, expectedValue) {
    console.log('[TestBloc] captureAssertion called:', assertionType, expectedValue);
    const locators = captureLocators(element);
    const qaId = ensureQaId(element);

    const step = {
      action: 'assert',
      assertionType,
      description: `Assert ${assertionType.replace('_', ' ')}`,
      locators,
      qaId,
      value: expectedValue,
      tagName: element.tagName.toLowerCase(),
      url: window.location.href,
    };

    sendStep(step);
  }

  // ============================================
  // EVENT CAPTURE
  // ============================================

  function handleClick(event) {
    if (!isRecording) return;

    // Ignore clicks on our UI
    if (event.target.closest('#testbloc-recorder-root') ||
        event.target.closest('#testbloc-assertion-popup')) {
      return;
    }

    // Assertion mode - select element for assertion
    if (isAssertionMode) {
      console.log('[TestBloc] Assertion mode click on:', event.target.tagName);
      event.preventDefault();
      event.stopPropagation();
      showAssertionPopup(event.target, event.clientX, event.clientY);
      return;
    }

    const element = event.target;
    const locators = captureLocators(element);
    const qaId = ensureQaId(element);

    const step = {
      action: 'click',
      description: `Click on ${describeElement(element)}`,
      locators,
      qaId,
      tagName: element.tagName.toLowerCase(),
      inputType: element.type || undefined,
      url: window.location.href,
    };

    sendStep(step);
  }

  function handleInput(event) {
    if (!isRecording || isAssertionMode) return;

    const element = event.target;

    // Only capture on input/textarea/select
    if (!['INPUT', 'TEXTAREA', 'SELECT'].includes(element.tagName)) return;

    console.log('[TestBloc] Input detected on:', element.tagName, 'value:', element.value?.substring(0, 20));

    // Ignore our UI
    if (element.closest('#testbloc-recorder-root')) return;

    const locators = captureLocators(element);
    const qaId = ensureQaId(element);

    // Debounce input events
    clearTimeout(element.__testblocInputTimeout);
    element.__testblocInputTimeout = setTimeout(() => {
      const step = {
        action: element.tagName === 'SELECT' ? 'select' : 'fill',
        description: `${element.tagName === 'SELECT' ? 'Select' : 'Type'} "${element.value?.substring(0, 50)}" in ${describeElement(element)}`,
        locators,
        qaId,
        value: element.value,
        tagName: element.tagName.toLowerCase(),
        inputType: element.type || undefined,
        url: window.location.href,
      };

      sendStep(step);
    }, 500);
  }

  function handleMouseover(event) {
    if (!isAssertionMode) return;

    const element = event.target;

    // Ignore our UI
    if (element.closest('#testbloc-recorder-root') ||
        element.closest('#testbloc-assertion-popup') ||
        element.id === 'testbloc-assertion-overlay') {
      return;
    }

    highlightElement(element);
  }

  function describeElement(element) {
    const role = inferRole(element);
    const name = getAccessibleName(element);

    if (name) {
      return `"${name.substring(0, 30)}"`;
    }

    if (role) {
      return role;
    }

    return element.tagName.toLowerCase();
  }

  // ============================================
  // STEP SENDING
  // ============================================

  function sendStep(step) {
    console.log('[TestBloc] Step captured:', step);

    chrome.runtime.sendMessage({
      type: 'STEP_CAPTURED',
      payload: step,
    }).catch(error => {
      console.error('[TestBloc] Failed to send step:', error);
    });
  }

  // ============================================
  // RECORDING CONTROL
  // ============================================

  function startRecording(context) {
    if (isRecording) return;

    recordingContext = context;
    isRecording = true;

    createBadgeUI();
    attachEventListeners();

    console.log('[TestBloc] Recording started for:', context.testName);
  }

  function stopRecording(source = 'unknown') {
    if (!isRecording) return;

    isRecording = false;
    isAssertionMode = false;

    detachEventListeners();
    removeBadgeUI();
    removeAssertionOverlay();
    removeAssertionPopup();
    document.body.style.cursor = '';

    console.log('[TestBloc] Recording stopped by:', source);

    chrome.runtime.sendMessage({
      type: 'STOP_RECORDING',
      source,
    }).catch(() => {});
  }

  function attachEventListeners() {
    document.addEventListener('click', handleClick, true);
    document.addEventListener('input', handleInput, true);
    document.addEventListener('change', handleInput, true);
    document.addEventListener('mouseover', handleMouseover, true);
  }

  function detachEventListeners() {
    document.removeEventListener('click', handleClick, true);
    document.removeEventListener('input', handleInput, true);
    document.removeEventListener('change', handleInput, true);
    document.removeEventListener('mouseover', handleMouseover, true);
  }

  // ============================================
  // MESSAGE HANDLING
  // ============================================

  chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
    console.log('[TestBloc Content] Message received:', message.type);

    switch (message.type) {
      case 'START_RECORDING':
        startRecording(message.payload);
        sendResponse({ success: true });
        break;

      case 'STOP_RECORDING':
        stopRecording('background');
        sendResponse({ success: true });
        break;

      case 'GET_STATUS':
        sendResponse({
          isRecording,
          isAssertionMode,
          testId: recordingContext.testId,
        });
        break;
    }
  });

  // Check if we should be recording on load
  chrome.runtime.sendMessage({ type: 'GET_RECORDING_STATE' })
    .then(state => {
      if (state && state.isRecording && state.recordingTabId) {
        // We might be the recording tab after a navigation
        chrome.tabs.getCurrent?.()?.then(tab => {
          if (tab?.id === state.recordingTabId) {
            startRecording({
              testId: state.testId,
              testName: state.testName,
              baseUrl: state.baseUrl,
            });
          }
        });
      }
    })
    .catch(() => {});

  console.log('[TestBloc] Content script loaded');
})();
